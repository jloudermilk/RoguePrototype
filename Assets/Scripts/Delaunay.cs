//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace Delauney
{
	public class Point2D
	{
		public float x, y;

		public Point2D ()
		{
			x = 0;
			y = 0;
		}

		public Point2D (float a_X, float a_Y)
		{
			x = a_X;
			y = a_Y;
		}

		public float Distance (Point2D A, Point2D B)
		{
			return (float)Math.Sqrt ((B.x + A.x) * (B.x + A.x) + (B.y + A.y) * (B.y + A.y));
		}

		public float Distance (Point2D B)
		{
			return (float)Math.Sqrt ((B.x - x) * (B.x - x) + (B.y - y) * (B.y - y));
		}
	}

	public class Edge
	{
		public Point2D A, B;

		public Edge ()
		{
		}

		public Edge (Point2D a_A, Point2D a_B)
		{
			A = a_A;
			B = a_B;
		}


	}
	
	public class Circle
	{
		public Point2D center;
		public float radius;
		
		public Circle ()
		{
			radius = 0;
			center = new Point2D ();
		}

		public bool Inside (Point2D B)
		{
			float dis = center.Distance(B);
			if (radius >= dis)
				return true;
			return false;
		}
		
	}

	public class Triangle
	{
		public Point2D A, B, C;
		public Circle Circle;

		public Edge AB {
			get{ return new Edge (A, B);}

		}

		public Edge BC {
			get{ return new Edge (B, C);}
		}

		public Edge CA {
			get{ return new Edge (C, A);}
		}

		public Triangle ()
		{
		}

		public Triangle (Point2D a_A, Point2D a_B, Point2D a_C)
		{
			A = a_A;
			B = a_B;
			C = a_C;
			CircumCircle ();
		}

		public Circle CircumCircle ()
		{
			Circle = new Circle ();
			if (Circle.radius == 0) {
				Circle.center = CircumCenter ();
				Circle.radius = Circle.center.Distance (A);
			}
			return Circle;

		}

		public Point2D CircumCenter ()
		{
			Point2D center = new Point2D ();
			float Divisor = 2 * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));
			float Ax2, Ay2, Bx2, By2, Cx2, Cy2, A2,B2,C2;
			Ax2 = (A.x*A.x);
			Bx2 = (B.x*B.x);
			Cx2 = (C.x*C.x);

			Ay2 = (A.y*A.y);
			By2 = (B.y*B.y);
			Cy2 = (C.y*C.y);

			A2 = Ax2 + Ay2;
			B2 = Bx2 + By2;
			C2 = Cx2 + Cy2;

			center.x = ((((A2) * (B.y - C.y)) + ((B2) * (C.y - A.y)) + ((C2) * (A.y - B.y))) / Divisor);
			center.y = ((((A2) * (C.x - B.x)) + ((B2) * (A.x - C.x)) + ((C2) * (B.x - A.x))) / Divisor);
			return center;
		}
	}

	//wrappers to overcome a mono debuggin error
	public class Point2DList: List<Point2D>
	{
		public void SortX ()
		{
			Point2D temp = new Point2D ();
			bool sorted = false;
			while (!sorted) {
				sorted = true;
				for (int i = this.Count-1; i > 0; i--) {
					if(this[i].x< this[i-1].x)
					{
						sorted = false;
						temp = this[i-1];
						this[i-1] = this[i];
						this[i] = temp;
					}
				}
			}
		}
	}
	public class EdgeList:List<Edge>
	{
	}
	public class TriangleList:List<Triangle>
	{
	}

	public class Delaunay
	{

		public TriangleList triList;
		public EdgeList eList;
		public Point2DList vertexList;

		public Delaunay ()
		{
		}
		public void MakeEdgeList()
		{

		}
		public void Triangulate (Point2DList inputList)
		{
			vertexList = new Point2DList ();
			triList = new TriangleList ();
			vertexList = inputList;

			triList.Add (new Triangle (vertexList [0], vertexList [1], vertexList [2]));

			for (int i = 3; i < vertexList.Count; i++) {
				for (int j = triList.Count; j > 0; j--) {
					bool tri1Check = false;
					bool tri2Check = false;
					bool tri3Check = false;

					Triangle tri1 = new Triangle (triList [j - 1].A, triList [j - 1].B, vertexList [i]);
					Triangle tri2 = new Triangle (triList [j - 1].C, triList [j - 1].B, vertexList [i]);
					Triangle tri3 = new Triangle (triList [j - 1].A, triList [j - 1].C, vertexList [i]);

					for (int k = 0; k <= i; k++) {
						if (!tri1Check)
							tri1Check = tri1.Circle.Inside (vertexList [k]);

						if (!tri2Check)
							tri2Check = tri2.Circle.Inside (vertexList [k]);

						if (!tri3Check)
							tri3Check = tri3.Circle.Inside (vertexList [k]);
					
					}
					if (!tri1Check)
						triList.Add (tri1);
					if (!tri2Check)
						triList.Add (tri2);
					if (!tri3Check)
						triList.Add (tri3);

				}
			}
			int z = 0;

		}

	}
}

